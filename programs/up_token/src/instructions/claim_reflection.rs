use anchor_lang::prelude::*; use anchor_spl::token::{self, Token, TokenAccount, Transfer}; use crate::state::*;
#[derive(Accounts)] pub struct ClaimReflection<'info>{ #[account(mut)] pub config: Account<'info, GlobalConfig>, #[account(mut, seeds=[b"holder", signer.key().as_ref()], bump=holder_state.bump)] pub holder_state: Account<'info, HolderState>, #[account(mut)] pub reflection_vault: Account<'info, TokenAccount>, #[account(mut)] pub holder_token: Account<'info, TokenAccount>, pub token_program: Program<'info, Token>, #[account(mut)] pub signer: Signer<'info> }
pub fn handler(ctx: Context<ClaimReflection>) -> Result<()> { let amount=ctx.accounts.holder_state.unclaimed_reflection; if amount==0{return Ok(());} let cpi=Transfer{ from: ctx.accounts.reflection_vault.to_account_info(), to: ctx.accounts.holder_token.to_account_info(), authority: ctx.accounts.signer.to_account_info() }; token::transfer(CpiContext::new(ctx.accounts.token_program.to_account_info(), cpi), amount)?; Ok(()) }
