"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rpc-websockets";
exports.ids = ["vendor-chunks/rpc-websockets"];
exports.modules = {

/***/ "(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/eventemitter3/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxnQkFBZ0IsWUFBWTtBQUM1Qjs7QUFFQTtBQUNBLDREQUE0RDtBQUM1RCxnRUFBZ0U7QUFDaEUsb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQTZCO0FBQ2pDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91cC13ZWIvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanM/OTNjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/rpc-websockets/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CommonClient: () => (/* binding */ CommonClient),\n/* harmony export */   DefaultDataPack: () => (/* binding */ DefaultDataPack),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   WebSocket: () => (/* binding */ WebSocket),\n/* harmony export */   createError: () => (/* binding */ createError)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"(ssr)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/v1.js\");\n\n\n\n\n\n// src/lib/client/websocket.ts\nfunction WebSocket(address, options) {\n  return new ws__WEBPACK_IMPORTED_MODULE_0__[\"default\"](address, options);\n}\n\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n  encode(value) {\n    return JSON.stringify(value);\n  }\n  decode(value) {\n    return JSON.parse(value);\n  }\n};\n\n// src/lib/client.ts\nvar CommonClient = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n  address;\n  rpc_id;\n  queue;\n  options;\n  autoconnect;\n  ready;\n  reconnect;\n  reconnect_timer_id;\n  reconnect_interval;\n  max_reconnects;\n  rest_options;\n  current_reconnects;\n  generate_request_id;\n  socket;\n  webSocketFactory;\n  dataPack;\n  /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */\n  constructor(webSocketFactory, address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1e3,\n    max_reconnects = 5,\n    ...rest_options\n  } = {}, generate_request_id, dataPack) {\n    super();\n    this.webSocketFactory = webSocketFactory;\n    this.queue = {};\n    this.rpc_id = 0;\n    this.address = address;\n    this.autoconnect = autoconnect;\n    this.ready = false;\n    this.reconnect = reconnect;\n    this.reconnect_timer_id = void 0;\n    this.reconnect_interval = reconnect_interval;\n    this.max_reconnects = max_reconnects;\n    this.rest_options = rest_options;\n    this.current_reconnects = 0;\n    this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === \"number\" ? ++this.rpc_id : Number(this.rpc_id) + 1);\n    if (!dataPack) this.dataPack = new DefaultDataPack();\n    else this.dataPack = dataPack;\n    if (this.autoconnect)\n      this._connect(this.address, {\n        autoconnect: this.autoconnect,\n        reconnect: this.reconnect,\n        reconnect_interval: this.reconnect_interval,\n        max_reconnects: this.max_reconnects,\n        ...this.rest_options\n      });\n  }\n  /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */\n  connect() {\n    if (this.socket) return;\n    this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */\n  call(method, params, timeout, ws_opts) {\n    if (!ws_opts && \"object\" === typeof timeout) {\n      ws_opts = timeout;\n      timeout = null;\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const rpc_id = this.generate_request_id(method, params);\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params: params || void 0,\n        id: rpc_id\n      };\n      this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {\n        if (error) return reject(error);\n        this.queue[rpc_id] = { promise: [resolve, reject] };\n        if (timeout) {\n          this.queue[rpc_id].timeout = setTimeout(() => {\n            delete this.queue[rpc_id];\n            reject(new Error(\"reply timeout\"));\n          }, timeout);\n        }\n      });\n    });\n  }\n  /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */\n  async login(params) {\n    const resp = await this.call(\"rpc.login\", params);\n    if (!resp) throw new Error(\"authentication failed\");\n    return resp;\n  }\n  /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */\n  async listMethods() {\n    return await this.call(\"__listMethods\");\n  }\n  /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */\n  notify(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params\n      };\n      this.socket.send(this.dataPack.encode(message), (error) => {\n        if (error) return reject(error);\n        resolve();\n      });\n    });\n  }\n  /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async subscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.on\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\")\n      throw new Error(\n        \"Failed subscribing to an event '\" + event + \"' with: \" + result[event]\n      );\n    return result;\n  }\n  /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async unsubscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.off\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\")\n      throw new Error(\"Failed unsubscribing from an event with: \" + result);\n    return result;\n  }\n  /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */\n  close(code, data) {\n    if (this.socket) this.socket.close(code || 1e3, data);\n  }\n  /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */\n  setAutoReconnect(reconnect) {\n    this.reconnect = reconnect;\n  }\n  /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */\n  setReconnectInterval(interval) {\n    this.reconnect_interval = interval;\n  }\n  /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */\n  setMaxReconnects(max_reconnects) {\n    this.max_reconnects = max_reconnects;\n  }\n  /**\n  * Get the current number of reconnection attempts made.\n  * @method\n  * @return {Number} current reconnection attempts\n  */\n  getCurrentReconnects() {\n    return this.current_reconnects;\n  }\n  /**\n  * Get the maximum number of reconnection attempts.\n  * @method\n  * @return {Number} maximum reconnection attempts\n  */\n  getMaxReconnects() {\n    return this.max_reconnects;\n  }\n  /**\n  * Check if the client is currently attempting to reconnect.\n  * @method\n  * @return {Boolean} true if reconnection is in progress\n  */\n  isReconnecting() {\n    return this.reconnect_timer_id !== void 0;\n  }\n  /**\n  * Check if the client will attempt to reconnect on the next close event.\n  * @method\n  * @return {Boolean} true if reconnection will be attempted\n  */\n  willReconnect() {\n    return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);\n  }\n  /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */\n  _connect(address, options) {\n    clearTimeout(this.reconnect_timer_id);\n    this.socket = this.webSocketFactory(address, options);\n    this.socket.addEventListener(\"open\", () => {\n      this.ready = true;\n      this.emit(\"open\");\n      this.current_reconnects = 0;\n    });\n    this.socket.addEventListener(\"message\", ({ data: message }) => {\n      if (message instanceof ArrayBuffer)\n        message = Buffer.from(message).toString();\n      try {\n        message = this.dataPack.decode(message);\n      } catch (error) {\n        return;\n      }\n      if (message.notification && this.listeners(message.notification).length) {\n        if (!Object.keys(message.params).length)\n          return this.emit(message.notification);\n        const args = [message.notification];\n        if (message.params.constructor === Object) args.push(message.params);\n        else\n          for (let i = 0; i < message.params.length; i++)\n            args.push(message.params[i]);\n        return Promise.resolve().then(() => {\n          this.emit.apply(this, args);\n        });\n      }\n      if (!this.queue[message.id]) {\n        if (message.method) {\n          return Promise.resolve().then(() => {\n            this.emit(message.method, message?.params);\n          });\n        }\n        return;\n      }\n      if (\"error\" in message === \"result\" in message)\n        this.queue[message.id].promise[1](\n          new Error(\n            'Server response malformed. Response must include either \"result\" or \"error\", but not both.'\n          )\n        );\n      if (this.queue[message.id].timeout)\n        clearTimeout(this.queue[message.id].timeout);\n      if (message.error) this.queue[message.id].promise[1](message.error);\n      else this.queue[message.id].promise[0](message.result);\n      delete this.queue[message.id];\n    });\n    this.socket.addEventListener(\"error\", (error) => this.emit(\"error\", error));\n    this.socket.addEventListener(\"close\", ({ code, reason }) => {\n      if (this.ready)\n        setTimeout(() => this.emit(\"close\", code, reason), 0);\n      this.ready = false;\n      this.socket = void 0;\n      if (code === 1e3) return;\n      this.current_reconnects++;\n      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0))\n        this.reconnect_timer_id = setTimeout(\n          () => this._connect(address, options),\n          this.reconnect_interval\n        );\n      else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {\n        setTimeout(() => this.emit(\"max_reconnects_reached\", code, reason), 1);\n      }\n    });\n  }\n};\nvar Server = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n  namespaces;\n  dataPack;\n  wss;\n  /**\n  * Instantiate a Server class.\n  * @constructor\n  * @param {Object} options - ws constructor's parameters with rpc\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {Server} - returns a new Server instance\n  */\n  constructor(options, dataPack) {\n    super();\n    this.namespaces = {};\n    if (!dataPack) this.dataPack = new DefaultDataPack();\n    else this.dataPack = dataPack;\n    this.wss = new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocketServer(options);\n    this.wss.on(\"listening\", () => this.emit(\"listening\"));\n    this.wss.on(\"connection\", (socket, request) => {\n      const u = node_url__WEBPACK_IMPORTED_MODULE_2__.parse(request.url, true);\n      const ns = u.pathname;\n      if (u.query.socket_id) socket._id = u.query.socket_id;\n      else socket._id = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n      socket[\"_authenticated\"] = false;\n      socket.on(\"error\", (error) => this.emit(\"socket-error\", socket, error));\n      socket.on(\"close\", () => {\n        this.namespaces[ns].clients.delete(socket._id);\n        for (const event of Object.keys(this.namespaces[ns].events)) {\n          const index = this.namespaces[ns].events[event].sockets.indexOf(\n            socket._id\n          );\n          if (index >= 0)\n            this.namespaces[ns].events[event].sockets.splice(index, 1);\n        }\n        this.emit(\"disconnection\", socket);\n      });\n      if (!this.namespaces[ns]) this._generateNamespace(ns);\n      this.namespaces[ns].clients.set(socket._id, socket);\n      this.emit(\"connection\", socket, request);\n      return this._handleRPC(socket, ns);\n    });\n    this.wss.on(\"error\", (error) => this.emit(\"error\", error));\n  }\n  /**\n  * Registers an RPC method.\n  * @method\n  * @param {String} name - method name\n  * @param {Function} fn - a callee function\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IMethod object\n  */\n  register(name, fn, ns = \"/\") {\n    if (!this.namespaces[ns]) this._generateNamespace(ns);\n    this.namespaces[ns].rpc_methods[name] = {\n      fn,\n      protected: false\n    };\n    return {\n      protected: () => this._makeProtectedMethod(name, ns),\n      public: () => this._makePublicMethod(name, ns)\n    };\n  }\n  /**\n  * Sets an auth method.\n  * @method\n  * @param {Function} fn - an arbitrary auth method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */\n  setAuth(fn, ns = \"/\") {\n    this.register(\"rpc.login\", fn, ns);\n  }\n  /**\n  * Marks an RPC method as protected.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makeProtectedMethod(name, ns = \"/\") {\n    this.namespaces[ns].rpc_methods[name].protected = true;\n  }\n  /**\n  * Marks an RPC method as public.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makePublicMethod(name, ns = \"/\") {\n    this.namespaces[ns].rpc_methods[name].protected = false;\n  }\n  /**\n  * Marks an event as protected.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makeProtectedEvent(name, ns = \"/\") {\n    this.namespaces[ns].events[name].protected = true;\n  }\n  /**\n  * Marks an event as public.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */\n  _makePublicEvent(name, ns = \"/\") {\n    this.namespaces[ns].events[name].protected = false;\n  }\n  /**\n  * Removes a namespace and closes all connections\n  * @method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */\n  closeNamespace(ns) {\n    const namespace = this.namespaces[ns];\n    if (namespace) {\n      delete namespace.rpc_methods;\n      delete namespace.events;\n      for (const socket of namespace.clients.values()) socket.close();\n      delete this.namespaces[ns];\n    }\n  }\n  /**\n  * Creates a new event that can be emitted to clients.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IEvent object\n  */\n  event(name, ns = \"/\") {\n    if (!this.namespaces[ns]) this._generateNamespace(ns);\n    else {\n      const index = this.namespaces[ns].events[name];\n      if (index !== void 0)\n        throw new Error(`Already registered event ${ns}${name}`);\n    }\n    this.namespaces[ns].events[name] = {\n      sockets: [],\n      protected: false\n    };\n    this.on(name, (...params) => {\n      if (params.length === 1 && params[0] instanceof Object)\n        params = params[0];\n      for (const socket_id of this.namespaces[ns].events[name].sockets) {\n        const socket = this.namespaces[ns].clients.get(socket_id);\n        if (!socket) continue;\n        socket.send(\n          this.dataPack.encode({\n            notification: name,\n            params\n          })\n        );\n      }\n    });\n    return {\n      protected: () => this._makeProtectedEvent(name, ns),\n      public: () => this._makePublicEvent(name, ns)\n    };\n  }\n  /**\n  * Returns a requested namespace object\n  * @method\n  * @param {String} name - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - namespace object\n  */\n  of(name) {\n    if (!this.namespaces[name]) this._generateNamespace(name);\n    const self = this;\n    return {\n      // self.register convenience method\n      register(fn_name, fn) {\n        if (arguments.length !== 2)\n          throw new Error(\"must provide exactly two arguments\");\n        if (typeof fn_name !== \"string\")\n          throw new Error(\"name must be a string\");\n        if (typeof fn !== \"function\")\n          throw new Error(\"handler must be a function\");\n        return self.register(fn_name, fn, name);\n      },\n      // self.event convenience method\n      event(ev_name) {\n        if (arguments.length !== 1)\n          throw new Error(\"must provide exactly one argument\");\n        if (typeof ev_name !== \"string\")\n          throw new Error(\"name must be a string\");\n        return self.event(ev_name, name);\n      },\n      // self.eventList convenience method\n      get eventList() {\n        return Object.keys(self.namespaces[name].events);\n      },\n      /**\n      * Emits a specified event to this namespace.\n      * @inner\n      * @method\n      * @param {String} event - event name\n      * @param {Array} params - event parameters\n      * @return {Undefined}\n      */\n      emit(event, ...params) {\n        const nsEvent = self.namespaces[name].events[event];\n        if (nsEvent)\n          for (const socket_id of nsEvent.sockets) {\n            const socket = self.namespaces[name].clients.get(socket_id);\n            if (!socket) continue;\n            socket.send(\n              self.dataPack.encode({\n                notification: event,\n                params\n              })\n            );\n          }\n      },\n      /**\n      * Returns a name of this namespace.\n      * @inner\n      * @method\n      * @kind constant\n      * @return {String}\n      */\n      get name() {\n        return name;\n      },\n      /**\n      * Returns a hash of websocket objects connected to this namespace.\n      * @inner\n      * @method\n      * @return {Object}\n      */\n      connected() {\n        const socket_ids = [...self.namespaces[name].clients.keys()];\n        return socket_ids.reduce(\n          (acc, curr) => ({\n            ...acc,\n            [curr]: self.namespaces[name].clients.get(curr)\n          }),\n          {}\n        );\n      },\n      /**\n      * Returns a list of client unique identifiers connected to this namespace.\n      * @inner\n      * @method\n      * @return {Array}\n      */\n      clients() {\n        return self.namespaces[name];\n      }\n    };\n  }\n  /**\n  * Lists all created events in a given namespace. Defaults to \"/\".\n  * @method\n  * @param {String} ns - namespaces identifier\n  * @readonly\n  * @return {Array} - returns a list of created events\n  */\n  eventList(ns = \"/\") {\n    if (!this.namespaces[ns]) return [];\n    return Object.keys(this.namespaces[ns].events);\n  }\n  /**\n  * Creates a JSON-RPC 2.0 compliant error\n  * @method\n  * @param {Number} code - indicates the error type that occurred\n  * @param {String} message - provides a short description of the error\n  * @param {String|Object} data - details containing additional information about the error\n  * @return {Object}\n  */\n  createError(code, message, data) {\n    return {\n      code,\n      message,\n      data: data || null\n    };\n  }\n  /**\n  * Closes the server and terminates all clients.\n  * @method\n  * @return {Promise}\n  */\n  close() {\n    return new Promise((resolve, reject) => {\n      try {\n        this.wss.close();\n        this.emit(\"close\");\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  /**\n  * Handles all WebSocket JSON RPC 2.0 requests.\n  * @private\n  * @param {Object} socket - ws socket instance\n  * @param {String} ns - namespaces identifier\n  * @return {Undefined}\n  */\n  _handleRPC(socket, ns = \"/\") {\n    socket.on(\"message\", async (data) => {\n      const msg_options = {};\n      if (data instanceof ArrayBuffer) {\n        msg_options.binary = true;\n        data = Buffer.from(data).toString();\n      }\n      if (socket.readyState !== 1) return;\n      let parsedData;\n      try {\n        parsedData = this.dataPack.decode(data);\n      } catch (error) {\n        return socket.send(\n          this.dataPack.encode({\n            jsonrpc: \"2.0\",\n            error: createError(-32700, error.toString()),\n            id: null\n          }),\n          msg_options\n        );\n      }\n      if (Array.isArray(parsedData)) {\n        if (!parsedData.length)\n          return socket.send(\n            this.dataPack.encode({\n              jsonrpc: \"2.0\",\n              error: createError(-32600, \"Invalid array\"),\n              id: null\n            }),\n            msg_options\n          );\n        const responses = [];\n        for (const message of parsedData) {\n          const response2 = await this._runMethod(message, socket._id, ns);\n          if (!response2) continue;\n          responses.push(response2);\n        }\n        if (!responses.length) return;\n        return socket.send(this.dataPack.encode(responses), msg_options);\n      }\n      const response = await this._runMethod(parsedData, socket._id, ns);\n      if (!response) return;\n      return socket.send(this.dataPack.encode(response), msg_options);\n    });\n  }\n  /**\n  * Runs a defined RPC method.\n  * @private\n  * @param {Object} message - a message received\n  * @param {Object} socket_id - user's socket id\n  * @param {String} ns - namespaces identifier\n  * @return {Object|undefined}\n  */\n  async _runMethod(message, socket_id, ns = \"/\") {\n    if (typeof message !== \"object\" || message === null)\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600),\n        id: null\n      };\n    if (message.jsonrpc !== \"2.0\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600, \"Invalid JSON RPC version\"),\n        id: message.id || null\n      };\n    if (!message.method)\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32602, \"Method not specified\"),\n        id: message.id || null\n      };\n    if (typeof message.method !== \"string\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600, \"Invalid method name\"),\n        id: message.id || null\n      };\n    if (message.params && typeof message.params === \"string\")\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32600),\n        id: message.id || null\n      };\n    if (message.method === \"rpc.on\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32e3),\n          id: message.id || null\n        };\n      const results = {};\n      const event_names = Object.keys(this.namespaces[ns].events);\n      for (const name of message.params) {\n        const index = event_names.indexOf(name);\n        const namespace = this.namespaces[ns];\n        if (index === -1) {\n          results[name] = \"provided event invalid\";\n          continue;\n        }\n        if (namespace.events[event_names[index]].protected === true && namespace.clients.get(socket_id)[\"_authenticated\"] === false) {\n          return {\n            jsonrpc: \"2.0\",\n            error: createError(-32606),\n            id: message.id || null\n          };\n        }\n        const socket_index = namespace.events[event_names[index]].sockets.indexOf(socket_id);\n        if (socket_index >= 0) {\n          results[name] = \"socket has already been subscribed to event\";\n          continue;\n        }\n        namespace.events[event_names[index]].sockets.push(socket_id);\n        results[name] = \"ok\";\n      }\n      return {\n        jsonrpc: \"2.0\",\n        result: results,\n        id: message.id || null\n      };\n    } else if (message.method === \"rpc.off\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32e3),\n          id: message.id || null\n        };\n      const results = {};\n      for (const name of message.params) {\n        if (!this.namespaces[ns].events[name]) {\n          results[name] = \"provided event invalid\";\n          continue;\n        }\n        const index = this.namespaces[ns].events[name].sockets.indexOf(socket_id);\n        if (index === -1) {\n          results[name] = \"not subscribed\";\n          continue;\n        }\n        this.namespaces[ns].events[name].sockets.splice(index, 1);\n        results[name] = \"ok\";\n      }\n      return {\n        jsonrpc: \"2.0\",\n        result: results,\n        id: message.id || null\n      };\n    } else if (message.method === \"rpc.login\") {\n      if (!message.params)\n        return {\n          jsonrpc: \"2.0\",\n          error: createError(-32604),\n          id: message.id || null\n        };\n    }\n    if (!this.namespaces[ns].rpc_methods[message.method]) {\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32601),\n        id: message.id || null\n      };\n    }\n    let response = null;\n    if (this.namespaces[ns].rpc_methods[message.method].protected === true && this.namespaces[ns].clients.get(socket_id)[\"_authenticated\"] === false) {\n      return {\n        jsonrpc: \"2.0\",\n        error: createError(-32605),\n        id: message.id || null\n      };\n    }\n    try {\n      response = await this.namespaces[ns].rpc_methods[message.method].fn(\n        message.params,\n        socket_id\n      );\n    } catch (error) {\n      if (!message.id) return;\n      if (error instanceof Error)\n        return {\n          jsonrpc: \"2.0\",\n          error: {\n            code: -32e3,\n            message: error.name,\n            data: error.message\n          },\n          id: message.id\n        };\n      return {\n        jsonrpc: \"2.0\",\n        error,\n        id: message.id\n      };\n    }\n    if (!message.id) return;\n    if (message.method === \"rpc.login\" && response === true) {\n      const s = this.namespaces[ns].clients.get(socket_id);\n      s[\"_authenticated\"] = true;\n      this.namespaces[ns].clients.set(socket_id, s);\n    }\n    return {\n      jsonrpc: \"2.0\",\n      result: response,\n      id: message.id\n    };\n  }\n  /**\n  * Generate a new namespace store.\n  * Also preregister some special namespace methods.\n  * @private\n  * @param {String} name - namespaces identifier\n  * @return {undefined}\n  */\n  _generateNamespace(name) {\n    this.namespaces[name] = {\n      rpc_methods: {\n        __listMethods: {\n          fn: () => Object.keys(this.namespaces[name].rpc_methods),\n          protected: false\n        }\n      },\n      clients: /* @__PURE__ */ new Map(),\n      events: {}\n    };\n  }\n};\nvar RPC_ERRORS = /* @__PURE__ */ new Map([\n  [-32e3, \"Event not provided\"],\n  [-32600, \"Invalid Request\"],\n  [-32601, \"Method not found\"],\n  [-32602, \"Invalid params\"],\n  [-32603, \"Internal error\"],\n  [-32604, \"Params not found\"],\n  [-32605, \"Method forbidden\"],\n  [-32606, \"Event forbidden\"],\n  [-32700, \"Parse error\"]\n]);\nfunction createError(code, details) {\n  const error = {\n    code,\n    message: RPC_ERRORS.get(code) || \"Internal Server Error\"\n  };\n  if (details) error[\"data\"] = details;\n  return error;\n}\n\n// src/index.ts\nvar Client = class extends CommonClient {\n  constructor(address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1e3,\n    max_reconnects = 5,\n    ...rest_options\n  } = {}, generate_request_id) {\n    super(\n      WebSocket,\n      address,\n      {\n        autoconnect,\n        reconnect,\n        reconnect_interval,\n        max_reconnects,\n        ...rest_options\n      },\n      generate_request_id\n    );\n  }\n};\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNQO0FBQ2xCO0FBQ0Q7O0FBRTFCO0FBQ0E7QUFDQSxhQUFhLDBDQUFhO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyx1REFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBZTtBQUNsQztBQUNBO0FBQ0EsZ0JBQWdCLDJDQUFTO0FBQ3pCO0FBQ0E7QUFDQSx3QkFBd0IsZ0RBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEdBQUcsRUFBRSxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxlQUFlO0FBQzNCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVpRjtBQUNqRjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdXAtd2ViLy4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL2Rpc3QvaW5kZXgubWpzP2YzNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFdlYlNvY2tldEltcGwsIHsgV2ViU29ja2V0U2VydmVyIH0gZnJvbSAnd3MnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgdXJsIGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCB7IHYxIH0gZnJvbSAndXVpZCc7XG5cbi8vIHNyYy9saWIvY2xpZW50L3dlYnNvY2tldC50c1xuZnVuY3Rpb24gV2ViU29ja2V0KGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBXZWJTb2NrZXRJbXBsKGFkZHJlc3MsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvbGliL3V0aWxzLnRzXG52YXIgRGVmYXVsdERhdGFQYWNrID0gY2xhc3Mge1xuICBlbmNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG4gIGRlY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9jbGllbnQudHNcbnZhciBDb21tb25DbGllbnQgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGFkZHJlc3M7XG4gIHJwY19pZDtcbiAgcXVldWU7XG4gIG9wdGlvbnM7XG4gIGF1dG9jb25uZWN0O1xuICByZWFkeTtcbiAgcmVjb25uZWN0O1xuICByZWNvbm5lY3RfdGltZXJfaWQ7XG4gIHJlY29ubmVjdF9pbnRlcnZhbDtcbiAgbWF4X3JlY29ubmVjdHM7XG4gIHJlc3Rfb3B0aW9ucztcbiAgY3VycmVudF9yZWNvbm5lY3RzO1xuICBnZW5lcmF0ZV9yZXF1ZXN0X2lkO1xuICBzb2NrZXQ7XG4gIHdlYlNvY2tldEZhY3Rvcnk7XG4gIGRhdGFQYWNrO1xuICAvKipcbiAgKiBJbnN0YW50aWF0ZSBhIENsaWVudCBjbGFzcy5cbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge3dlYlNvY2tldEZhY3Rvcnl9IHdlYlNvY2tldEZhY3RvcnkgLSBmYWN0b3J5IG1ldGhvZCBmb3IgV2ViU29ja2V0XG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSB1cmwgdG8gYSB3ZWJzb2NrZXQgc2VydmVyXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBvcHRpb25zIG9iamVjdCB3aXRoIHJlY29ubmVjdCBwYXJhbWV0ZXJzXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZ2VuZXJhdGVfcmVxdWVzdF9pZCAtIGN1c3RvbSBnZW5lcmF0aW9uIHJlcXVlc3QgSWRcbiAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICogQHJldHVybiB7Q29tbW9uQ2xpZW50fVxuICAqL1xuICBjb25zdHJ1Y3Rvcih3ZWJTb2NrZXRGYWN0b3J5LCBhZGRyZXNzID0gXCJ3czovL2xvY2FsaG9zdDo4MDgwXCIsIHtcbiAgICBhdXRvY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3RfaW50ZXJ2YWwgPSAxZTMsXG4gICAgbWF4X3JlY29ubmVjdHMgPSA1LFxuICAgIC4uLnJlc3Rfb3B0aW9uc1xuICB9ID0ge30sIGdlbmVyYXRlX3JlcXVlc3RfaWQsIGRhdGFQYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLndlYlNvY2tldEZhY3RvcnkgPSB3ZWJTb2NrZXRGYWN0b3J5O1xuICAgIHRoaXMucXVldWUgPSB7fTtcbiAgICB0aGlzLnJwY19pZCA9IDA7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmF1dG9jb25uZWN0ID0gYXV0b2Nvbm5lY3Q7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMucmVjb25uZWN0ID0gcmVjb25uZWN0O1xuICAgIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkID0gdm9pZCAwO1xuICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gcmVjb25uZWN0X2ludGVydmFsO1xuICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0cztcbiAgICB0aGlzLnJlc3Rfb3B0aW9ucyA9IHJlc3Rfb3B0aW9ucztcbiAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkID0gZ2VuZXJhdGVfcmVxdWVzdF9pZCB8fCAoKCkgPT4gdHlwZW9mIHRoaXMucnBjX2lkID09PSBcIm51bWJlclwiID8gKyt0aGlzLnJwY19pZCA6IE51bWJlcih0aGlzLnJwY19pZCkgKyAxKTtcbiAgICBpZiAoIWRhdGFQYWNrKSB0aGlzLmRhdGFQYWNrID0gbmV3IERlZmF1bHREYXRhUGFjaygpO1xuICAgIGVsc2UgdGhpcy5kYXRhUGFjayA9IGRhdGFQYWNrO1xuICAgIGlmICh0aGlzLmF1dG9jb25uZWN0KVxuICAgICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdDogdGhpcy5yZWNvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgICAuLi50aGlzLnJlc3Rfb3B0aW9uc1xuICAgICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQ29ubmVjdHMgdG8gYSBkZWZpbmVkIHNlcnZlciBpZiBub3QgY29ubmVjdGVkIGFscmVhZHkuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHJldHVybjtcbiAgICB0aGlzLl9jb25uZWN0KHRoaXMuYWRkcmVzcywge1xuICAgICAgYXV0b2Nvbm5lY3Q6IHRoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgcmVjb25uZWN0X2ludGVydmFsOiB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiB0aGlzLm1heF9yZWNvbm5lY3RzLFxuICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBDYWxscyBhIHJlZ2lzdGVyZWQgUlBDIG1ldGhvZCBvbiBzZXJ2ZXIuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIFJQQyByZXBseSB0aW1lb3V0IHZhbHVlXG4gICogQHBhcmFtIHtPYmplY3R9IHdzX29wdHMgLSBvcHRpb25zIHBhc3NlZCB0byB3c1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGNhbGwobWV0aG9kLCBwYXJhbXMsIHRpbWVvdXQsIHdzX29wdHMpIHtcbiAgICBpZiAoIXdzX29wdHMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRpbWVvdXQpIHtcbiAgICAgIHdzX29wdHMgPSB0aW1lb3V0O1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICBjb25zdCBycGNfaWQgPSB0aGlzLmdlbmVyYXRlX3JlcXVlc3RfaWQobWV0aG9kLCBwYXJhbXMpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCB2b2lkIDAsXG4gICAgICAgIGlkOiBycGNfaWRcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKG1lc3NhZ2UpLCB3c19vcHRzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgdGhpcy5xdWV1ZVtycGNfaWRdID0geyBwcm9taXNlOiBbcmVzb2x2ZSwgcmVqZWN0XSB9O1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIHRoaXMucXVldWVbcnBjX2lkXS50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZVtycGNfaWRdO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJlcGx5IHRpbWVvdXRcIikpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBMb2dpbnMgd2l0aCB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIExvZ2luIGNyZWRlbnRpYWxzIG9iamVjdFxuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIGFzeW5jIGxvZ2luKHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMubG9naW5cIiwgcGFyYW1zKTtcbiAgICBpZiAoIXJlc3ApIHRocm93IG5ldyBFcnJvcihcImF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiKTtcbiAgICByZXR1cm4gcmVzcDtcbiAgfVxuICAvKipcbiAgKiBGZXRjaGVzIGEgbGlzdCBvZiBjbGllbnQncyBtZXRob2RzIHJlZ2lzdGVyZWQgb24gc2VydmVyLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtBcnJheX1cbiAgKi9cbiAgYXN5bmMgbGlzdE1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsbChcIl9fbGlzdE1ldGhvZHNcIik7XG4gIH1cbiAgLyoqXG4gICogU2VuZHMgYSBKU09OLVJQQyAyLjAgbm90aWZpY2F0aW9uIHRvIHNlcnZlci5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIFJQQyBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBvcHRpb25hbCBtZXRob2QgcGFyYW1ldGVyc1xuICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG4gIG5vdGlmeShtZXRob2QsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHBhcmFtc1xuICAgICAgfTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUobWVzc2FnZSksIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBTdWJzY3JpYmVzIGZvciBhIGRlZmluZWQgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudCAtIGV2ZW50IG5hbWVcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICogQHRocm93cyB7RXJyb3J9XG4gICovXG4gIGFzeW5jIHN1YnNjcmliZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIGV2ZW50ID0gW2V2ZW50XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMub25cIiwgZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgJiYgcmVzdWx0W2V2ZW50XSAhPT0gXCJva1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkZhaWxlZCBzdWJzY3JpYmluZyB0byBhbiBldmVudCAnXCIgKyBldmVudCArIFwiJyB3aXRoOiBcIiArIHJlc3VsdFtldmVudF1cbiAgICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgKiBVbnN1YnNjcmliZXMgZnJvbSBhIGRlZmluZWQgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBldmVudCAtIGV2ZW50IG5hbWVcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICogQHRocm93cyB7RXJyb3J9XG4gICovXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikgZXZlbnQgPSBbZXZlbnRdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5vZmZcIiwgZXZlbnQpO1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIgJiYgcmVzdWx0W2V2ZW50XSAhPT0gXCJva1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHVuc3Vic2NyaWJpbmcgZnJvbSBhbiBldmVudCB3aXRoOiBcIiArIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgKiBDbG9zZXMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBncmFjZWZ1bGx5LlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIHNvY2tldCBjbG9zZSBjb2RlXG4gICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSBvcHRpb25hbCBkYXRhIHRvIGJlIHNlbnQgYmVmb3JlIGNsb3NpbmdcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNsb3NlKGNvZGUsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQpIHRoaXMuc29ja2V0LmNsb3NlKGNvZGUgfHwgMWUzLCBkYXRhKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGUgLyBkaXNhYmxlIGF1dG9tYXRpYyByZWNvbm5lY3Rpb24uXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVjb25uZWN0IC0gZW5hYmxlIC8gZGlzYWJsZSByZWNvbm5lY3Rpb25cbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIHNldEF1dG9SZWNvbm5lY3QocmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QgPSByZWNvbm5lY3Q7XG4gIH1cbiAgLyoqXG4gICogU2V0IHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsIC0gcmVjb25uZWN0aW9uIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0UmVjb25uZWN0SW50ZXJ2YWwoaW50ZXJ2YWwpIHtcbiAgICB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCA9IGludGVydmFsO1xuICB9XG4gIC8qKlxuICAqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge051bWJlcn0gbWF4X3JlY29ubmVjdHMgLSBtYXhpbXVtIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0TWF4UmVjb25uZWN0cyhtYXhfcmVjb25uZWN0cykge1xuICAgIHRoaXMubWF4X3JlY29ubmVjdHMgPSBtYXhfcmVjb25uZWN0cztcbiAgfVxuICAvKipcbiAgKiBHZXQgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBtYWRlLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IGN1cnJlbnQgcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICovXG4gIGdldEN1cnJlbnRSZWNvbm5lY3RzKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cztcbiAgfVxuICAvKipcbiAgKiBHZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7TnVtYmVyfSBtYXhpbXVtIHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAqL1xuICBnZXRNYXhSZWNvbm5lY3RzKCkge1xuICAgIHJldHVybiB0aGlzLm1heF9yZWNvbm5lY3RzO1xuICB9XG4gIC8qKlxuICAqIENoZWNrIGlmIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG8gcmVjb25uZWN0LlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHJlY29ubmVjdGlvbiBpcyBpbiBwcm9ncmVzc1xuICAqL1xuICBpc1JlY29ubmVjdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgIT09IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgKiBDaGVjayBpZiB0aGUgY2xpZW50IHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3Qgb24gdGhlIG5leHQgY2xvc2UgZXZlbnQuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcmVjb25uZWN0aW9uIHdpbGwgYmUgYXR0ZW1wdGVkXG4gICovXG4gIHdpbGxSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25uZWN0ICYmICh0aGlzLm1heF9yZWNvbm5lY3RzID09PSAwIHx8IHRoaXMuY3VycmVudF9yZWNvbm5lY3RzIDwgdGhpcy5tYXhfcmVjb25uZWN0cyk7XG4gIH1cbiAgLyoqXG4gICogQ29ubmVjdGlvbi9NZXNzYWdlIGhhbmRsZXIuXG4gICogQG1ldGhvZFxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBXZWJTb2NrZXQgQVBJIGFkZHJlc3NcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIG9wdGlvbnMgb2JqZWN0XG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfY29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0X3RpbWVyX2lkKTtcbiAgICB0aGlzLnNvY2tldCA9IHRoaXMud2ViU29ja2V0RmFjdG9yeShhZGRyZXNzLCBvcHRpb25zKTtcbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdChcIm9wZW5cIik7XG4gICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgfSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHsgZGF0YTogbWVzc2FnZSB9KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLmRhdGFQYWNrLmRlY29kZShtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNzYWdlLm5vdGlmaWNhdGlvbiAmJiB0aGlzLmxpc3RlbmVycyhtZXNzYWdlLm5vdGlmaWNhdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXMobWVzc2FnZS5wYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KG1lc3NhZ2Uubm90aWZpY2F0aW9uKTtcbiAgICAgICAgY29uc3QgYXJncyA9IFttZXNzYWdlLm5vdGlmaWNhdGlvbl07XG4gICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSBhcmdzLnB1c2gobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLnBhcmFtcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGFyZ3MucHVzaChtZXNzYWdlLnBhcmFtc1tpXSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZT8ucGFyYW1zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UgPT09IFwicmVzdWx0XCIgaW4gbWVzc2FnZSlcbiAgICAgICAgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzFdKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTZXJ2ZXIgcmVzcG9uc2UgbWFsZm9ybWVkLiBSZXNwb25zZSBtdXN0IGluY2x1ZGUgZWl0aGVyIFwicmVzdWx0XCIgb3IgXCJlcnJvclwiLCBidXQgbm90IGJvdGguJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGlmICh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpO1xuICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IpIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVsxXShtZXNzYWdlLmVycm9yKTtcbiAgICAgIGVsc2UgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzBdKG1lc3NhZ2UucmVzdWx0KTtcbiAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICh7IGNvZGUsIHJlYXNvbiB9KSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFkeSlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmVtaXQoXCJjbG9zZVwiLCBjb2RlLCByZWFzb24pLCAwKTtcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc29ja2V0ID0gdm9pZCAwO1xuICAgICAgaWYgKGNvZGUgPT09IDFlMykgcmV0dXJuO1xuICAgICAgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMrKztcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdCAmJiAodGhpcy5tYXhfcmVjb25uZWN0cyA+IHRoaXMuY3VycmVudF9yZWNvbm5lY3RzIHx8IHRoaXMubWF4X3JlY29ubmVjdHMgPT09IDApKVxuICAgICAgICB0aGlzLnJlY29ubmVjdF90aW1lcl9pZCA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgKCkgPT4gdGhpcy5fY29ubmVjdChhZGRyZXNzLCBvcHRpb25zKSxcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbFxuICAgICAgICApO1xuICAgICAgZWxzZSBpZiAodGhpcy5yZWNvbm5lY3QgJiYgdGhpcy5tYXhfcmVjb25uZWN0cyA+IDAgJiYgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgPj0gdGhpcy5tYXhfcmVjb25uZWN0cykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZW1pdChcIm1heF9yZWNvbm5lY3RzX3JlYWNoZWRcIiwgY29kZSwgcmVhc29uKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgU2VydmVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBuYW1lc3BhY2VzO1xuICBkYXRhUGFjaztcbiAgd3NzO1xuICAvKipcbiAgKiBJbnN0YW50aWF0ZSBhIFNlcnZlciBjbGFzcy5cbiAgKiBAY29uc3RydWN0b3JcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIGNvbnN0cnVjdG9yJ3MgcGFyYW1ldGVycyB3aXRoIHJwY1xuICAqIEBwYXJhbSB7RGF0YVBhY2t9IGRhdGFQYWNrIC0gZGF0YSBwYWNrIGNvbnRhaW5zIGVuY29kZXIgYW5kIGRlY29kZXJcbiAgKiBAcmV0dXJuIHtTZXJ2ZXJ9IC0gcmV0dXJucyBhIG5ldyBTZXJ2ZXIgaW5zdGFuY2VcbiAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgZGF0YVBhY2spIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZXNwYWNlcyA9IHt9O1xuICAgIGlmICghZGF0YVBhY2spIHRoaXMuZGF0YVBhY2sgPSBuZXcgRGVmYXVsdERhdGFQYWNrKCk7XG4gICAgZWxzZSB0aGlzLmRhdGFQYWNrID0gZGF0YVBhY2s7XG4gICAgdGhpcy53c3MgPSBuZXcgV2ViU29ja2V0U2VydmVyKG9wdGlvbnMpO1xuICAgIHRoaXMud3NzLm9uKFwibGlzdGVuaW5nXCIsICgpID0+IHRoaXMuZW1pdChcImxpc3RlbmluZ1wiKSk7XG4gICAgdGhpcy53c3Mub24oXCJjb25uZWN0aW9uXCIsIChzb2NrZXQsIHJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IHUgPSB1cmwucGFyc2UocmVxdWVzdC51cmwsIHRydWUpO1xuICAgICAgY29uc3QgbnMgPSB1LnBhdGhuYW1lO1xuICAgICAgaWYgKHUucXVlcnkuc29ja2V0X2lkKSBzb2NrZXQuX2lkID0gdS5xdWVyeS5zb2NrZXRfaWQ7XG4gICAgICBlbHNlIHNvY2tldC5faWQgPSB2MSgpO1xuICAgICAgc29ja2V0W1wiX2F1dGhlbnRpY2F0ZWRcIl0gPSBmYWxzZTtcbiAgICAgIHNvY2tldC5vbihcImVycm9yXCIsIChlcnJvcikgPT4gdGhpcy5lbWl0KFwic29ja2V0LWVycm9yXCIsIHNvY2tldCwgZXJyb3IpKTtcbiAgICAgIHNvY2tldC5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmRlbGV0ZShzb2NrZXQuX2lkKTtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cykpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW2V2ZW50XS5zb2NrZXRzLmluZGV4T2YoXG4gICAgICAgICAgICBzb2NrZXQuX2lkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMClcbiAgICAgICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW2V2ZW50XS5zb2NrZXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGlvblwiLCBzb2NrZXQpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHRoaXMuX2dlbmVyYXRlTmFtZXNwYWNlKG5zKTtcbiAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5zZXQoc29ja2V0Ll9pZCwgc29ja2V0KTtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25cIiwgc29ja2V0LCByZXF1ZXN0KTtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVSUEMoc29ja2V0LCBucyk7XG4gICAgfSk7XG4gICAgdGhpcy53c3Mub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKSk7XG4gIH1cbiAgLyoqXG4gICogUmVnaXN0ZXJzIGFuIFJQQyBtZXRob2QuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGEgY2FsbGVlIGZ1bmN0aW9uXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIHJldHVybnMgYW4gSU1ldGhvZCBvYmplY3RcbiAgKi9cbiAgcmVnaXN0ZXIobmFtZSwgZm4sIG5zID0gXCIvXCIpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHRoaXMuX2dlbmVyYXRlTmFtZXNwYWNlKG5zKTtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdID0ge1xuICAgICAgZm4sXG4gICAgICBwcm90ZWN0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvdGVjdGVkOiAoKSA9PiB0aGlzLl9tYWtlUHJvdGVjdGVkTWV0aG9kKG5hbWUsIG5zKSxcbiAgICAgIHB1YmxpYzogKCkgPT4gdGhpcy5fbWFrZVB1YmxpY01ldGhvZChuYW1lLCBucylcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIFNldHMgYW4gYXV0aCBtZXRob2QuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gYW4gYXJiaXRyYXJ5IGF1dGggbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRBdXRoKGZuLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5yZWdpc3RlcihcInJwYy5sb2dpblwiLCBmbiwgbnMpO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIFJQQyBtZXRob2QgYXMgcHJvdGVjdGVkLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHJvdGVjdGVkTWV0aG9kKG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdLnByb3RlY3RlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gUlBDIG1ldGhvZCBhcyBwdWJsaWMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQdWJsaWNNZXRob2QobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbmFtZV0ucHJvdGVjdGVkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gZXZlbnQgYXMgcHJvdGVjdGVkLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGV2ZW50IG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQcm90ZWN0ZWRFdmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0ucHJvdGVjdGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgKiBNYXJrcyBhbiBldmVudCBhcyBwdWJsaWMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gZXZlbnQgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfbWFrZVB1YmxpY0V2ZW50KG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5wcm90ZWN0ZWQgPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBSZW1vdmVzIGEgbmFtZXNwYWNlIGFuZCBjbG9zZXMgYWxsIGNvbm5lY3Rpb25zXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgY2xvc2VOYW1lc3BhY2UobnMpIHtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgIGRlbGV0ZSBuYW1lc3BhY2UucnBjX21ldGhvZHM7XG4gICAgICBkZWxldGUgbmFtZXNwYWNlLmV2ZW50cztcbiAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIG5hbWVzcGFjZS5jbGllbnRzLnZhbHVlcygpKSBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBDcmVhdGVzIGEgbmV3IGV2ZW50IHRoYXQgY2FuIGJlIGVtaXR0ZWQgdG8gY2xpZW50cy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBldmVudCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIHJldHVybnMgYW4gSUV2ZW50IG9iamVjdFxuICAqL1xuICBldmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdO1xuICAgICAgaWYgKGluZGV4ICE9PSB2b2lkIDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWxyZWFkeSByZWdpc3RlcmVkIGV2ZW50ICR7bnN9JHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXSA9IHtcbiAgICAgIHNvY2tldHM6IFtdLFxuICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5vbihuYW1lLCAoLi4ucGFyYW1zKSA9PiB7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0gaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgIHBhcmFtcyA9IHBhcmFtc1swXTtcbiAgICAgIGZvciAoY29uc3Qgc29ja2V0X2lkIG9mIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnNvY2tldHMpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpO1xuICAgICAgICBpZiAoIXNvY2tldCkgY29udGludWU7XG4gICAgICAgIHNvY2tldC5zZW5kKFxuICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogbmFtZSxcbiAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RlY3RlZDogKCkgPT4gdGhpcy5fbWFrZVByb3RlY3RlZEV2ZW50KG5hbWUsIG5zKSxcbiAgICAgIHB1YmxpYzogKCkgPT4gdGhpcy5fbWFrZVB1YmxpY0V2ZW50KG5hbWUsIG5zKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyBhIHJlcXVlc3RlZCBuYW1lc3BhY2Ugb2JqZWN0XG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICogQHJldHVybiB7T2JqZWN0fSAtIG5hbWVzcGFjZSBvYmplY3RcbiAgKi9cbiAgb2YobmFtZSkge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25hbWVdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShuYW1lKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgLy8gc2VsZi5yZWdpc3RlciBjb252ZW5pZW5jZSBtZXRob2RcbiAgICAgIHJlZ2lzdGVyKGZuX25hbWUsIGZuKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3QgcHJvdmlkZSBleGFjdGx5IHR3byBhcmd1bWVudHNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZm5fbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIHNlbGYucmVnaXN0ZXIoZm5fbmFtZSwgZm4sIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIHNlbGYuZXZlbnQgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICBldmVudChldl9uYW1lKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm11c3QgcHJvdmlkZSBleGFjdGx5IG9uZSBhcmd1bWVudFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBldl9uYW1lICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZXZlbnQoZXZfbmFtZSwgbmFtZSk7XG4gICAgICB9LFxuICAgICAgLy8gc2VsZi5ldmVudExpc3QgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICBnZXQgZXZlbnRMaXN0KCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VsZi5uYW1lc3BhY2VzW25hbWVdLmV2ZW50cyk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIEVtaXRzIGEgc3BlY2lmaWVkIGV2ZW50IHRvIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBldmVudCBuYW1lXG4gICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyAtIGV2ZW50IHBhcmFtZXRlcnNcbiAgICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAgKi9cbiAgICAgIGVtaXQoZXZlbnQsIC4uLnBhcmFtcykge1xuICAgICAgICBjb25zdCBuc0V2ZW50ID0gc2VsZi5uYW1lc3BhY2VzW25hbWVdLmV2ZW50c1tldmVudF07XG4gICAgICAgIGlmIChuc0V2ZW50KVxuICAgICAgICAgIGZvciAoY29uc3Qgc29ja2V0X2lkIG9mIG5zRXZlbnQuc29ja2V0cykge1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMuZ2V0KHNvY2tldF9pZCk7XG4gICAgICAgICAgICBpZiAoIXNvY2tldCkgY29udGludWU7XG4gICAgICAgICAgICBzb2NrZXQuc2VuZChcbiAgICAgICAgICAgICAgc2VsZi5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbjogZXZlbnQsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICogUmV0dXJucyBhIG5hbWUgb2YgdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBraW5kIGNvbnN0YW50XG4gICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICovXG4gICAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBoYXNoIG9mIHdlYnNvY2tldCBvYmplY3RzIGNvbm5lY3RlZCB0byB0aGlzIG5hbWVzcGFjZS5cbiAgICAgICogQGlubmVyXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgKi9cbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgY29uc3Qgc29ja2V0X2lkcyA9IFsuLi5zZWxmLm5hbWVzcGFjZXNbbmFtZV0uY2xpZW50cy5rZXlzKCldO1xuICAgICAgICByZXR1cm4gc29ja2V0X2lkcy5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgY3VycikgPT4gKHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIFtjdXJyXTogc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMuZ2V0KGN1cnIpXG4gICAgICAgICAgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICogUmV0dXJucyBhIGxpc3Qgb2YgY2xpZW50IHVuaXF1ZSBpZGVudGlmaWVycyBjb25uZWN0ZWQgdG8gdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgKi9cbiAgICAgIGNsaWVudHMoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLm5hbWVzcGFjZXNbbmFtZV07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBMaXN0cyBhbGwgY3JlYXRlZCBldmVudHMgaW4gYSBnaXZlbiBuYW1lc3BhY2UuIERlZmF1bHRzIHRvIFwiL1wiLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmVhZG9ubHlcbiAgKiBAcmV0dXJuIHtBcnJheX0gLSByZXR1cm5zIGEgbGlzdCBvZiBjcmVhdGVkIGV2ZW50c1xuICAqL1xuICBldmVudExpc3QobnMgPSBcIi9cIikge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXSkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cyk7XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlcyBhIEpTT04tUlBDIDIuMCBjb21wbGlhbnQgZXJyb3JcbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgLSBpbmRpY2F0ZXMgdGhlIGVycm9yIHR5cGUgdGhhdCBvY2N1cnJlZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gcHJvdmlkZXMgYSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgZXJyb3JcbiAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGEgLSBkZXRhaWxzIGNvbnRhaW5pbmcgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3JcbiAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICovXG4gIGNyZWF0ZUVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBkYXRhOiBkYXRhIHx8IG51bGxcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIENsb3NlcyB0aGUgc2VydmVyIGFuZCB0ZXJtaW5hdGVzIGFsbCBjbGllbnRzLlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53c3MuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogSGFuZGxlcyBhbGwgV2ViU29ja2V0IEpTT04gUlBDIDIuMCByZXF1ZXN0cy5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXQgLSB3cyBzb2NrZXQgaW5zdGFuY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9oYW5kbGVSUEMoc29ja2V0LCBucyA9IFwiL1wiKSB7XG4gICAgc29ja2V0Lm9uKFwibWVzc2FnZVwiLCBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgY29uc3QgbXNnX29wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgbXNnX29wdGlvbnMuYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IDEpIHJldHVybjtcbiAgICAgIGxldCBwYXJzZWREYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkRGF0YSA9IHRoaXMuZGF0YVBhY2suZGVjb2RlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKFxuICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNzAwLCBlcnJvci50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbXNnX29wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZERhdGEpKSB7XG4gICAgICAgIGlmICghcGFyc2VkRGF0YS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKFxuICAgICAgICAgICAgdGhpcy5kYXRhUGFjay5lbmNvZGUoe1xuICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgYXJyYXlcIiksXG4gICAgICAgICAgICAgIGlkOiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1zZ19vcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwYXJzZWREYXRhKSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgdGhpcy5fcnVuTWV0aG9kKG1lc3NhZ2UsIHNvY2tldC5faWQsIG5zKTtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlMikgY29udGludWU7XG4gICAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVzcG9uc2UyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKHJlc3BvbnNlcyksIG1zZ19vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fcnVuTWV0aG9kKHBhcnNlZERhdGEsIHNvY2tldC5faWQsIG5zKTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHJldHVybjtcbiAgICAgIHJldHVybiBzb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShyZXNwb25zZSksIG1zZ19vcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBSdW5zIGEgZGVmaW5lZCBSUEMgbWV0aG9kLlxuICAqIEBwcml2YXRlXG4gICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2UgLSBhIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgKiBAcGFyYW0ge09iamVjdH0gc29ja2V0X2lkIC0gdXNlcidzIHNvY2tldCBpZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZXMgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gICovXG4gIGFzeW5jIF9ydW5NZXRob2QobWVzc2FnZSwgc29ja2V0X2lkLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwKSxcbiAgICAgICAgaWQ6IG51bGxcbiAgICAgIH07XG4gICAgaWYgKG1lc3NhZ2UuanNvbnJwYyAhPT0gXCIyLjBcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDAsIFwiSW52YWxpZCBKU09OIFJQQyB2ZXJzaW9uXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmICghbWVzc2FnZS5tZXRob2QpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAyLCBcIk1ldGhvZCBub3Qgc3BlY2lmaWVkXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tZXRob2QgIT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgbWV0aG9kIG5hbWVcIiksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgaWYgKG1lc3NhZ2UucGFyYW1zICYmIHR5cGVvZiBtZXNzYWdlLnBhcmFtcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDApLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMub25cIikge1xuICAgICAgaWYgKCFtZXNzYWdlLnBhcmFtcylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzJlMyksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICAgICAgY29uc3QgZXZlbnRfbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50cyk7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBldmVudF9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZXNbbnNdO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwicHJvdmlkZWQgZXZlbnQgaW52YWxpZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0ucHJvdGVjdGVkID09PSB0cnVlICYmIG5hbWVzcGFjZS5jbGllbnRzLmdldChzb2NrZXRfaWQpW1wiX2F1dGhlbnRpY2F0ZWRcIl0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA2KSxcbiAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldF9pbmRleCA9IG5hbWVzcGFjZS5ldmVudHNbZXZlbnRfbmFtZXNbaW5kZXhdXS5zb2NrZXRzLmluZGV4T2Yoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKHNvY2tldF9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gc3Vic2NyaWJlZCB0byBldmVudFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzcGFjZS5ldmVudHNbZXZlbnRfbmFtZXNbaW5kZXhdXS5zb2NrZXRzLnB1c2goc29ja2V0X2lkKTtcbiAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwib2tcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5vZmZcIikge1xuICAgICAgaWYgKCFtZXNzYWdlLnBhcmFtcylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzJlMyksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICByZXN1bHRzW25hbWVdID0gXCJwcm92aWRlZCBldmVudCBpbnZhbGlkXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5zb2NrZXRzLmluZGV4T2Yoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcIm5vdCBzdWJzY3JpYmVkXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0uc29ja2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXN1bHRzW25hbWVdID0gXCJva1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgcmVzdWx0OiByZXN1bHRzLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5tZXRob2QgPT09IFwicnBjLmxvZ2luXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA0KSxcbiAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcigtMzI2MDEpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgIGlmICh0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW21lc3NhZ2UubWV0aG9kXS5wcm90ZWN0ZWQgPT09IHRydWUgJiYgdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpW1wiX2F1dGhlbnRpY2F0ZWRcIl0gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjA1KSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0uZm4oXG4gICAgICAgIG1lc3NhZ2UucGFyYW1zLFxuICAgICAgICBzb2NrZXRfaWRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkgcmV0dXJuO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgY29kZTogLTMyZTMsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5uYW1lLFxuICAgICAgICAgICAgZGF0YTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBpZDogbWVzc2FnZS5pZFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlLmlkKSByZXR1cm47XG4gICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5sb2dpblwiICYmIHJlc3BvbnNlID09PSB0cnVlKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5uYW1lc3BhY2VzW25zXS5jbGllbnRzLmdldChzb2NrZXRfaWQpO1xuICAgICAgc1tcIl9hdXRoZW50aWNhdGVkXCJdID0gdHJ1ZTtcbiAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5zZXQoc29ja2V0X2lkLCBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICByZXN1bHQ6IHJlc3BvbnNlLFxuICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIEdlbmVyYXRlIGEgbmV3IG5hbWVzcGFjZSBzdG9yZS5cbiAgKiBBbHNvIHByZXJlZ2lzdGVyIHNvbWUgc3BlY2lhbCBuYW1lc3BhY2UgbWV0aG9kcy5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAqL1xuICBfZ2VuZXJhdGVOYW1lc3BhY2UobmFtZSkge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuYW1lXSA9IHtcbiAgICAgIHJwY19tZXRob2RzOiB7XG4gICAgICAgIF9fbGlzdE1ldGhvZHM6IHtcbiAgICAgICAgICBmbjogKCkgPT4gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25hbWVdLnJwY19tZXRob2RzKSxcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGllbnRzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgZXZlbnRzOiB7fVxuICAgIH07XG4gIH1cbn07XG52YXIgUlBDX0VSUk9SUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgWy0zMmUzLCBcIkV2ZW50IG5vdCBwcm92aWRlZFwiXSxcbiAgWy0zMjYwMCwgXCJJbnZhbGlkIFJlcXVlc3RcIl0sXG4gIFstMzI2MDEsIFwiTWV0aG9kIG5vdCBmb3VuZFwiXSxcbiAgWy0zMjYwMiwgXCJJbnZhbGlkIHBhcmFtc1wiXSxcbiAgWy0zMjYwMywgXCJJbnRlcm5hbCBlcnJvclwiXSxcbiAgWy0zMjYwNCwgXCJQYXJhbXMgbm90IGZvdW5kXCJdLFxuICBbLTMyNjA1LCBcIk1ldGhvZCBmb3JiaWRkZW5cIl0sXG4gIFstMzI2MDYsIFwiRXZlbnQgZm9yYmlkZGVuXCJdLFxuICBbLTMyNzAwLCBcIlBhcnNlIGVycm9yXCJdXG5dKTtcbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKGNvZGUsIGRldGFpbHMpIHtcbiAgY29uc3QgZXJyb3IgPSB7XG4gICAgY29kZSxcbiAgICBtZXNzYWdlOiBSUENfRVJST1JTLmdldChjb2RlKSB8fCBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG4gIH07XG4gIGlmIChkZXRhaWxzKSBlcnJvcltcImRhdGFcIl0gPSBkZXRhaWxzO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIENsaWVudCA9IGNsYXNzIGV4dGVuZHMgQ29tbW9uQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoYWRkcmVzcyA9IFwid3M6Ly9sb2NhbGhvc3Q6ODA4MFwiLCB7XG4gICAgYXV0b2Nvbm5lY3QgPSB0cnVlLFxuICAgIHJlY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0X2ludGVydmFsID0gMWUzLFxuICAgIG1heF9yZWNvbm5lY3RzID0gNSxcbiAgICAuLi5yZXN0X29wdGlvbnNcbiAgfSA9IHt9LCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKSB7XG4gICAgc3VwZXIoXG4gICAgICBXZWJTb2NrZXQsXG4gICAgICBhZGRyZXNzLFxuICAgICAge1xuICAgICAgICBhdXRvY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0LFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgIG1heF9yZWNvbm5lY3RzLFxuICAgICAgICAuLi5yZXN0X29wdGlvbnNcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZV9yZXF1ZXN0X2lkXG4gICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgQ2xpZW50LCBDb21tb25DbGllbnQsIERlZmF1bHREYXRhUGFjaywgU2VydmVyLCBXZWJTb2NrZXQsIGNyZWF0ZUVycm9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQzs7QUFFZDtBQUN2QixpRUFBZSxzQ0FBWSIsInNvdXJjZXMiOlsid2VicGFjazovL3VwLXdlYi8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5tanM/NDliYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vaW5kZXguanMnXG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs\n");

/***/ })

};
;